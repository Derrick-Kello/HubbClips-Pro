<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CapCut-Style Video Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .editor-container {
            display: grid;
            grid-template-columns: 300px 1fr 280px;
            grid-template-rows: 60px 1fr 240px;
            height: 100vh;
            gap: 1px;
            background: #333;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid #444;
        }

        .logo {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4facfe;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-primary { background: #4facfe; color: white; }
        .btn-secondary { background: #444; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffa502; color: white; }

        .btn:hover { opacity: 0.8; transform: translateY(-1px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* Media Panel */
        .media-panel {
            background: #262626;
            padding: 15px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #ccc;
        }

        .upload-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .upload-zone:hover {
            border-color: #4facfe;
            background: rgba(79, 172, 254, 0.05);
        }

        .media-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .media-item {
            background: #333;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .media-item:hover { background: #3a3a3a; }
        .media-item.selected { background: #4facfe; }

        .media-name {
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .media-info {
            font-size: 0.75rem;
            color: #aaa;
            display: flex;
            justify-content: space-between;
        }

        .effect-item {
            cursor: grab;
        }

        .effect-item:hover {
            background: #3a3a3a;
            transform: translateY(-1px);
        }

        /* Preview Area */
        .preview-area {
            background: #1f1f1f;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000;
        }

        .preview-video {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }

        .preview-placeholder {
            text-align: center;
            color: #666;
            font-size: 1.1rem;
        }

        .playback-controls {
            padding: 15px;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #4facfe;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .time-display {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #ccc;
            min-width: 50px;
        }

        .playback-slider {
            flex: 1;
            height: 4px;
            background: #444;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .slider-progress {
            height: 100%;
            background: #4facfe;
            border-radius: 2px;
            position: relative;
        }

        .slider-handle {
            width: 12px;
            height: 12px;
            background: #4facfe;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            right: -6px;
            cursor: pointer;
        }

        /* Properties Panel */
        .properties-panel {
            background: #262626;
            padding: 15px;
            overflow-y: auto;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group h3 {
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: #ccc;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .form-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: white;
            font-size: 0.85rem;
        }

        .form-select {
            padding: 6px 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: white;
            font-size: 0.85rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .property-slider {
            flex: 1;
        }

        .slider-value {
            min-width: 40px;
            font-size: 0.8rem;
            color: #ccc;
        }

        /* Timeline */
        .timeline-area {
            grid-column: 1 / -1;
            background: #1f1f1f;
            display: flex;
            flex-direction: column;
        }

        .timeline-header {
            padding: 10px 20px;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #444;
        }

        .timeline-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .zoom-btn {
            width: 24px;
            height: 24px;
            border: 1px solid #555;
            background: #333;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timeline-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #1a1a1a;
        }

        .timeline-ruler {
            height: 30px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            position: relative;
            min-width: 800px;
        }

        .ruler-mark {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: #555;
        }

        .ruler-time {
            position: absolute;
            top: 5px;
            font-size: 0.7rem;
            color: #aaa;
            transform: translateX(-50%);
        }

        .playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #ff4757;
            z-index: 100;
            pointer-events: none;
        }

        .tracks-container {
            min-height: 180px;
        }

        .track {
            height: 60px;
            border-bottom: 1px solid #333;
            position: relative;
            display: flex;
            align-items: center;
        }

        .track-label {
            width: 80px;
            padding: 0 10px;
            font-size: 0.8rem;
            color: #ccc;
            border-right: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #262626;
            min-height: 60px;
        }

        .track-content {
            flex: 1;
            height: 100%;
            position: relative;
            padding: 5px;
            min-width: 720px;
        }

        .clip {
            position: absolute;
            height: 50px;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.8rem;
            font-weight: 500;
            user-select: none;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .clip.video {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 2px solid #667eea;
        }

        .clip.audio {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border: 2px solid #f093fb;
        }

        .clip.text {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            border: 2px solid #4facfe;
        }

        .clip.selected {
            border-color: #fff;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3), 0 2px 8px rgba(0,0,0,0.4);
        }

        .clip:hover {
            transform: translateY(-1px);
        }

        .clip-handle {
            position: absolute;
            top: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }

        .clip-handle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .clip-handle.left { left: 0; border-radius: 4px 0 0 4px; }
        .clip-handle.right { right: 0; border-radius: 0 4px 4px 0; }

        .clip-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Transitions */
        .transition {
            position: absolute;
            width: 20px;
            height: 30px;
            background: #ffa502;
            border-radius: 4px;
            top: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: white;
            z-index: 10;
        }

        /* Progress Overlay */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .progress-content {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-width: 300px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4facfe;
            transition: width 0.3s ease;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 5px 0;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .context-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .context-item:hover {
            background: #3a3a3a;
        }

        .context-separator {
            height: 1px;
            background: #444;
            margin: 5px 0;
        }

        /* Speed Control */
        .speed-indicator {
            position: absolute;
            top: -15px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: #ffa502;
            font-size: 0.7rem;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Waveform */
        .audio-waveform {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 10px;
            height: 20px;
            opacity: 0.6;
        }

        .waveform-bar {
            display: inline-block;
            width: 2px;
            background: #fff;
            margin-right: 1px;
            vertical-align: bottom;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .editor-container {
                grid-template-columns: 250px 1fr 250px;
            }
        }

        /* New Features Styling */
        .filter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .filter-btn {
            padding: 4px 8px;
            background: #444;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .filter-btn:hover {
            background: #555;
        }

        .filter-btn.active {
            background: #4facfe;
            border-color: #4facfe;
        }

        .snap-indicator {
            position: absolute;
            width: 2px;
            background: #ffa502;
            height: 100%;
            z-index: 50;
            pointer-events: none;
        }

        .magnet-active .clip {
            transition: transform 0.1s ease;
        }
    </style>
</head>
<body>
<div class="editor-container">
    <!-- Header -->
    <div class="header">
        <div class="logo">VideoEditor Pro</div>
        <div class="header-controls">
            <button class="btn btn-secondary" id="newProjectBtn">New Project</button>
            <button class="btn btn-secondary" id="openProjectBtn">Open Project</button>
            <button class="btn btn-secondary" id="saveProjectBtn">Save Project</button>
            <button class="btn btn-warning" id="magnetBtn" title="Toggle Snap">🧲</button>
            <button class="btn btn-success" id="exportBtn" disabled>Export Video</button>
        </div>
    </div>

    <!-- Media Panel -->
    <div class="media-panel">
        <div class="panel-section">
            <div class="panel-title">Media Library</div>
            <div class="upload-zone" id="mediaUpload">
                <div>Drop files here or click to browse</div>
                <small>Videos, Audio, Images</small>
            </div>
            <div class="media-list" id="mediaList">
                <div style="text-align: center; color: #666; padding: 20px;">
                    No media imported
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-title">Effects & Transitions</div>
            <div class="effects-list">
                <div class="media-item effect-item" data-effect="fade-in" draggable="true">
                    <div class="media-name">Fade In</div>
                </div>
                <div class="media-item effect-item" data-effect="fade-out" draggable="true">
                    <div class="media-name">Fade Out</div>
                </div>
                <div class="media-item effect-item" data-effect="crossfade" draggable="true">
                    <div class="media-name">Crossfade</div>
                </div>
                <div class="media-item effect-item" data-effect="blur" draggable="true">
                    <div class="media-name">Blur</div>
                </div>
                <div class="media-item effect-item" data-effect="brightness" draggable="true">
                    <div class="media-name">Brightness</div>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-title">Text Templates</div>
            <div class="text-templates">
                <div class="media-item effect-item" data-template="title" draggable="true">
                    <div class="media-name">Title</div>
                </div>
                <div class="media-item effect-item" data-template="subtitle" draggable="true">
                    <div class="media-name">Subtitle</div>
                </div>
                <div class="media-item effect-item" data-template="lower-third" draggable="true">
                    <div class="media-name">Lower Third</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Preview Area -->
    <div class="preview-area">
        <div class="preview-container" id="previewContainer">
            <div class="preview-placeholder" id="previewPlaceholder">
                <div>No video loaded</div>
                <div style="font-size: 0.8rem; margin-top: 10px;">Select a clip to preview</div>
            </div>
            <video class="preview-video" id="previewVideo" style="display: none;"></video>
        </div>
        <div class="playback-controls">
            <button class="play-btn" id="playBtn">▶</button>
            <span class="time-display" id="currentTime">00:00</span>
            <div class="playback-slider" id="playbackSlider">
                <div class="slider-progress" id="sliderProgress">
                    <div class="slider-handle" id="sliderHandle"></div>
                </div>
            </div>
            <span class="time-display" id="totalTime">00:00</span>
            <button class="btn btn-secondary btn-sm" id="frameBackBtn">⏪</button>
            <button class="btn btn-secondary btn-sm" id="frameForwardBtn">⏩</button>
        </div>
    </div>

    <!-- Properties Panel -->
    <div class="properties-panel">
        <div class="property-group">
            <h3>Clip Properties</h3>
            <div class="input-group">
                <input type="text" class="form-input" id="clipName" placeholder="Clip name">
            </div>
            <div class="input-group">
                <input type="number" class="form-input" id="clipStart" placeholder="Start time" step="0.1">
                <input type="number" class="form-input" id="clipEnd" placeholder="End time" step="0.1">
            </div>
            <div class="input-group">
                <label style="font-size: 0.8rem; color: #ccc;">Speed:</label>
                <select class="form-select" id="clipSpeed">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                    <option value="4">4x</option>
                </select>
            </div>
            <button class="btn btn-primary" id="applyClipChanges" disabled>Apply Changes</button>
        </div>

        <div class="property-group">
            <h3>Visual Effects</h3>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 60px;">Opacity:</label>
                <input type="range" class="property-slider" id="opacitySlider" min="0" max="100" value="100">
                <span class="slider-value" id="opacityValue">100%</span>
            </div>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 60px;">Blur:</label>
                <input type="range" class="property-slider" id="blurSlider" min="0" max="10" value="0" step="0.1">
                <span class="slider-value" id="blurValue">0</span>
            </div>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 60px;">Bright:</label>
                <input type="range" class="property-slider" id="brightnessSlider" min="-50" max="50" value="0">
                <span class="slider-value" id="brightnessValue">0</span>
            </div>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 60px;">Contrast:</label>
                <input type="range" class="property-slider" id="contrastSlider" min="0" max="200" value="100">
                <span class="slider-value" id="contrastValue">100%</span>
            </div>
        </div>

        <div class="property-group">
            <h3>Transform</h3>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 60px;">Scale:</label>
                <input type="range" class="property-slider" id="scaleSlider" min="10" max="200" value="100">
                <span class="slider-value" id="scaleValue">100%</span>
            </div>
            <div class="input-group">
                <input type="number" class="form-input" id="posX" placeholder="X" value="0">
                <input type="number" class="form-input" id="posY" placeholder="Y" value="0">
                <input type="number" class="form-input" id="rotation" placeholder="Rotation" value="0" step="1">
            </div>
        </div>

        <div class="property-group">
            <h3>Video Settings</h3>
            <div class="input-group">
                <select class="form-select" id="videoQuality">
                    <option value="1080p">1080p (1920x1080)</option>
                    <option value="720p">720p (1280x720)</option>
                    <option value="480p">480p (854x480)</option>
                </select>
            </div>
            <div class="input-group">
                <select class="form-select" id="videoFormat">
                    <option value="mp4">MP4</option>
                    <option value="avi">AVI</option>
                    <option value="mov">MOV</option>
                    <option value="webm">WebM</option>
                </select>
            </div>
            <div class="slider-container">
                <label style="font-size: 0.8rem; color: #ccc; min-width: 50px;">Bitrate:</label>
                <input type="range" class="property-slider" id="videoBitrate" min="1" max="50" value="8">
                <span class="slider-value" id="bitrateValue">8 Mbps</span>
            </div>
        </div>

        <div class="property-group">
            <h3>Tools</h3>
            <div class="filter-controls">
                <button class="filter-btn" id="snapBtn">Snap</button>
                <button class="filter-btn" id="rippleBtn">Ripple</button>
                <button class="filter-btn" id="razorBtn">Razor</button>
            </div>
            <button class="btn btn-secondary" id="splitClipBtn" disabled>Split Clip</button>
            <button class="btn btn-secondary" id="duplicateClipBtn" disabled>Duplicate</button>
            <button class="btn btn-danger" id="deleteClipBtn" disabled>Delete Clip</button>
            <button class="btn btn-warning" id="reverseClipBtn" disabled>Reverse</button>
            <button class="btn btn-secondary" id="extractAudioBtn" disabled>Extract Audio</button>
        </div>
    </div>

    <!-- Timeline Area -->
    <div class="timeline-area">
        <div class="timeline-header">
            <div class="timeline-controls">
                <span style="font-size: 0.9rem; color: #ccc;">Timeline</span>
                <button class="btn btn-secondary btn-sm" id="addTrackBtn">+ Track</button>
                <button class="btn btn-secondary btn-sm" id="fitToWindowBtn">Fit</button>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">-</button>
                <span style="font-size: 0.8rem; color: #ccc;" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomIn">+</button>
            </div>
        </div>
        <div class="timeline-container" id="timelineContainer">
            <div class="timeline-ruler" id="timelineRuler">
                <div class="playhead" id="playhead"></div>
            </div>
            <div class="tracks-container" id="tracksContainer">
                <div class="track" id="videoTrack">
                    <div class="track-label">Video 1</div>
                    <div class="track-content" id="videoTrackContent"></div>
                </div>
                <div class="track" id="audioTrack">
                    <div class="track-label">Audio 1</div>
                    <div class="track-content" id="audioTrackContent"></div>
                </div>
                <div class="track" id="textTrack">
                    <div class="track-label">Text</div>
                    <div class="track-content" id="textTrackContent"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Progress Overlay -->
<div class="progress-overlay" id="progressOverlay">
    <div class="progress-content">
        <h3 id="progressTitle">Processing...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="progressText">0%</div>
    </div>
</div>

<!-- Context Menu -->
<div class="context-menu" id="contextMenu">
    <div class="context-item" id="contextDelete">Delete</div>
</div>

<script>
    // Enhanced Video Editor Application
    class VideoEditor {
        constructor() {
            this.project = {
                name: 'Untitled Project',
                timeline: {
                    duration: 0,
                    tracks: {
                        video: [],
                        audio: [],
                        text: []
                    }
                },
                settings: {
                    resolution: '1080p',
                    format: 'mp4',
                    bitrate: 8,
                    fps: 30
                }
            };

            this.mediaLibrary = [];
            this.selectedClip = null;
            this.playhead = 0;
            this.isPlaying = false;
            this.zoomLevel = 1;
            this.pixelsPerSecond = 100;
            this.snapEnabled = true;
            this.rippleMode = false;
            this.razorMode = false;
            this.dragState = null;
            this.copiedClip = null;

            // Timeline interaction state
            this.timelineScroll = 0;
            this.trackCount = { video: 1, audio: 1, text: 1 };

            this.initializeElements();
            this.bindEvents();
            this.updateTimeline();
            this.initializePropertyControls();
        }

        initializeElements() {
            // Media elements
            this.mediaUpload = document.getElementById('mediaUpload');
            this.mediaList = document.getElementById('mediaList');

            // Preview elements
            this.previewVideo = document.getElementById('previewVideo');
            this.previewPlaceholder = document.getElementById('previewPlaceholder');
            this.playBtn = document.getElementById('playBtn');
            this.currentTime = document.getElementById('currentTime');
            this.totalTime = document.getElementById('totalTime');
            this.playbackSlider = document.getElementById('playbackSlider');
            this.sliderProgress = document.getElementById('sliderProgress');

            // Timeline elements
            this.timelineContainer = document.getElementById('timelineContainer');
            this.timelineRuler = document.getElementById('timelineRuler');
            this.playheadElement = document.getElementById('playhead');
            this.tracksContainer = document.getElementById('tracksContainer');
            this.videoTrackContent = document.getElementById('videoTrackContent');
            this.audioTrackContent = document.getElementById('audioTrackContent');
            this.textTrackContent = document.getElementById('textTrackContent');

            // Control elements
            this.exportBtn = document.getElementById('exportBtn');
            this.progressOverlay = document.getElementById('progressOverlay');
            this.contextMenu = document.getElementById('contextMenu');

            // Property elements
            this.clipName = document.getElementById('clipName');
            this.clipStart = document.getElementById('clipStart');
            this.clipEnd = document.getElementById('clipEnd');
            this.clipSpeed = document.getElementById('clipSpeed');
            this.videoBitrate = document.getElementById('videoBitrate');
            this.bitrateValue = document.getElementById('bitrateValue');

            // Tool buttons
            this.snapBtn = document.getElementById('snapBtn');
            this.rippleBtn = document.getElementById('rippleBtn');
            this.razorBtn = document.getElementById('razorBtn');
            this.magnetBtn = document.getElementById('magnetBtn');
        }

        bindEvents() {
            // Media upload
            this.mediaUpload.addEventListener('click', () => this.importMedia());
            this.mediaUpload.addEventListener('dragover', e => e.preventDefault());
            this.mediaUpload.addEventListener('drop', e => {
                e.preventDefault();
                this.handleFileDrop(e.dataTransfer.files);
            });

            // Preview controls
            this.playBtn.addEventListener('click', () => this.togglePlay());
            this.playbackSlider.addEventListener('click', e => this.scrubToPosition(e));
            document.getElementById('frameBackBtn').addEventListener('click', () => this.frameStep(-1));
            document.getElementById('frameForwardBtn').addEventListener('click', () => this.frameStep(1));

            // Timeline controls
            this.timelineRuler.addEventListener('click', e => this.scrubTimeline(e));
            this.timelineContainer.addEventListener('scroll', () => this.handleTimelineScroll());

            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => this.zoomIn());
            document.getElementById('zoomOut').addEventListener('click', () => this.zoomOut());
            document.getElementById('fitToWindowBtn').addEventListener('click', () => this.fitToWindow());
            document.getElementById('addTrackBtn').addEventListener('click', () => this.addTrack());

            // Tool toggles
            this.snapBtn.addEventListener('click', () => this.toggleSnap());
            this.rippleBtn.addEventListener('click', () => this.toggleRipple());
            this.razorBtn.addEventListener('click', () => this.toggleRazor());
            this.magnetBtn.addEventListener('click', () => this.toggleMagnet());

            // Project controls
            document.getElementById('newProjectBtn').addEventListener('click', () => this.newProject());
            document.getElementById('openProjectBtn').addEventListener('click', () => this.openProject());
            document.getElementById('saveProjectBtn').addEventListener('click', () => this.saveProject());

            // Export
            this.exportBtn.addEventListener('click', () => this.exportVideo());

            // Property controls
            this.videoBitrate.addEventListener('input', e => {
                this.bitrateValue.textContent = e.target.value + ' Mbps';
            });

            // Tool buttons
            document.getElementById('splitClipBtn').addEventListener('click', () => this.splitClip());
            document.getElementById('duplicateClipBtn').addEventListener('click', () => this.duplicateClip());
            document.getElementById('deleteClipBtn').addEventListener('click', () => this.deleteClip());
            document.getElementById('reverseClipBtn').addEventListener('click', () => this.reverseClip());
            document.getElementById('extractAudioBtn').addEventListener('click', () => this.extractAudio());
            document.getElementById('applyClipChanges').addEventListener('click', () => this.applyClipChanges());

            // Context menu
            document.addEventListener('contextmenu', e => this.showContextMenu(e));
            document.addEventListener('click', () => this.hideContextMenu());

            // Context menu items
            document.getElementById('contextCut').addEventListener('click', () => this.cutClip());
            document.getElementById('contextCopy').addEventListener('click', () => this.copyClip());
            document.getElementById('contextPaste').addEventListener('click', () => this.pasteClip());
            document.getElementById('contextSplit').addEventListener('click', () => this.splitClip());
            document.getElementById('contextDuplicate').addEventListener('click', () => this.duplicateClip());
            document.getElementById('contextReverse').addEventListener('click', () => this.reverseClip());
            document.getElementById('contextSpeed').addEventListener('click', () => this.showSpeedDialog());
            document.getElementById('contextExtractAudio').addEventListener('click', () => this.extractAudio());
            document.getElementById('contextDelete').addEventListener('click', () => this.deleteClip());

            // Keyboard shortcuts
            document.addEventListener('keydown', e => this.handleKeyboard(e));

            // Drag and drop for effects
            this.bindEffectDragAndDrop();
        }

        initializePropertyControls() {
            // Initialize all property sliders
            const sliders = [
                { id: 'opacitySlider', valueId: 'opacityValue', suffix: '%' },
                { id: 'blurSlider', valueId: 'blurValue', suffix: '' },
                { id: 'brightnessSlider', valueId: 'brightnessValue', suffix: '' },
                { id: 'contrastSlider', valueId: 'contrastValue', suffix: '%' },
                { id: 'scaleSlider', valueId: 'scaleValue', suffix: '%' }
            ];

            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);

                element.addEventListener('input', e => {
                    valueElement.textContent = e.target.value + slider.suffix;
                    this.updateClipEffects();
                });
            });

            // Speed control
            this.clipSpeed.addEventListener('change', () => {
                if (this.selectedClip) {
                    this.updateClipSpeed();
                }
            });

            // Transform controls
            ['posX', 'posY', 'rotation'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    this.updateClipTransform();
                });
            });
        }

        bindEffectDragAndDrop() {
            // Make effects draggable
            document.querySelectorAll('.effect-item').forEach(item => {
                item.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'effect',
                        effect: e.target.dataset.effect || e.target.dataset.template
                    }));
                });
            });

            // Make track contents accept effect drops
            [this.videoTrackContent, this.audioTrackContent, this.textTrackContent].forEach(track => {
                track.addEventListener('dragover', e => e.preventDefault());
                track.addEventListener('drop', e => this.handleEffectDrop(e));
            });
        }

        handleTimelineScroll() {
            this.timelineScroll = this.timelineContainer.scrollLeft;
            // Sync playhead position with scroll
            this.updatePlayheadPosition(this.playhead);
        }

        async importMedia() {
            if (!window.electronAPI) {
                this.showBrowserDemo();
                return;
            }

            try {
                const filePaths = await window.electronAPI.selectVideoFiles();
                if (filePaths.length === 0) return;

                this.showProgress('Importing Media');

                for (let i = 0; i < filePaths.length; i++) {
                    const filePath = filePaths[i];
                    console.log('Importing media:', filePath);

                    this.updateProgress((i / filePaths.length) * 100);

                    const mediaInfo = await window.electronAPI.getMediaInfo(filePath);
                    console.log('Media info received:', mediaInfo);
                    this.addToMediaLibrary(mediaInfo);
                }

                this.hideProgress();
            } catch (error) {
                console.error('Error importing media:', error);
                this.hideProgress();
                alert('Error importing media files: ' + error.message);
            }
        }

        showBrowserDemo() {
            // Demo data for browser testing
            const demoMedia = [
                {
                    id: 'demo_1',
                    fileName: 'Demo Video 1.mp4',
                    duration: 30,
                    hasVideo: true,
                    hasAudio: true,
                    filePath: 'demo',
                    video: { width: 1920, height: 1080, fps: 30 }
                },
                {
                    id: 'demo_2',
                    fileName: 'Demo Video 2.mp4',
                    duration: 20,
                    hasVideo: true,
                    hasAudio: false,
                    filePath: 'demo',
                    video: { width: 1280, height: 720, fps: 24 }
                },
                {
                    id: 'demo_3',
                    fileName: 'Demo Audio.mp3',
                    duration: 45,
                    hasVideo: false,
                    hasAudio: true,
                    filePath: 'demo'
                }
            ];

            demoMedia.forEach(media => this.addToMediaLibrary(media));

            alert('Demo mode: Click on media items and drag them to the timeline tracks below!');
        }

        handleFileDrop(files) {
            console.log('Files dropped:', files.length);
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (this.isValidMediaFile(file.name)) {
                    console.log('Dropped file:', file.name);
                }
            }

            if (window.electronAPI) {
                alert('Please use the file picker button to import media files.');
            } else {
                this.showBrowserDemo();
            }
        }

        isValidMediaFile(filename) {
            const videoExts = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv', '.m4v', '.wmv'];
            const audioExts = ['.mp3', '.wav', '.aac', '.m4a', '.flac', '.ogg'];
            const imageExts = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return [...videoExts, ...audioExts, ...imageExts].includes(ext);
        }

        addToMediaLibrary(mediaInfo) {
            this.mediaLibrary.push(mediaInfo);
            this.renderMediaLibrary();
        }

        renderMediaLibrary() {
            if (this.mediaLibrary.length === 0) {
                this.mediaList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No media imported</div>';
                return;
            }

            this.mediaList.innerHTML = this.mediaLibrary.map(item => `
                <div class="media-item" data-id="${item.id}" draggable="true">
                    <div class="media-name">${item.fileName}</div>
                    <div class="media-info">
                        <span>${this.formatTime(item.duration)}</span>
                        <span>${item.hasVideo ? (item.hasAudio ? 'Video+Audio' : 'Video') : 'Audio'}</span>
                    </div>
                </div>
            `).join('');

            // Add drag and drop functionality
            this.mediaList.querySelectorAll('.media-item').forEach(item => {
                item.addEventListener('dragstart', e => this.handleDragStart(e));
                item.addEventListener('click', e => this.selectMediaItem(e));
            });

            // Make track contents droppable
            [this.videoTrackContent, this.audioTrackContent, this.textTrackContent].forEach(track => {
                track.addEventListener('dragover', e => e.preventDefault());
                track.addEventListener('drop', e => this.handleTrackDrop(e));
            });
        }

        selectMediaItem(e) {
            // Remove previous selection
            this.mediaList.querySelectorAll('.media-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Add selection to clicked item
            e.target.closest('.media-item').classList.add('selected');

            // Preview the media
            const mediaId = e.target.closest('.media-item').dataset.id;
            const mediaItem = this.mediaLibrary.find(item => item.id === mediaId);
            if (mediaItem && mediaItem.hasVideo) {
                this.loadPreview(mediaItem);
            }
        }

        handleDragStart(e) {
            const mediaId = e.target.dataset.id;
            e.dataTransfer.setData('text/plain', JSON.stringify({
                type: 'media',
                mediaId: mediaId
            }));
        }

        handleTrackDrop(e) {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));

            if (data.type === 'media') {
                const mediaItem = this.mediaLibrary.find(item => item.id === data.mediaId);
                if (mediaItem) {
                    const trackType = this.getTrackTypeFromElement(e.currentTarget);
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = e.clientX - rect.left + this.timelineScroll;
                    const timePosition = Math.max(0, x / (this.pixelsPerSecond * this.zoomLevel));

                    this.addClipToTrack(mediaItem, trackType, timePosition);
                }
            } else if (data.type === 'effect') {
                this.handleEffectDrop(e);
            }
        }

        handleEffectDrop(e) {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));

            if (data.type === 'effect') {
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left + this.timelineScroll;
                const timePosition = x / (this.pixelsPerSecond * this.zoomLevel);

                // Find clip at this position
                const trackType = this.getTrackTypeFromElement(e.currentTarget);
                const clip = this.findClipAtPosition(trackType, timePosition);

                if (clip) {
                    this.applyEffectToClip(clip, data.effect);
                } else if (data.effect.includes('title') || data.effect.includes('text') || data.effect.includes('subtitle')) {
                    // Add text clip
                    this.addTextClip(data.effect, timePosition);
                }
            }
        }

        getTrackTypeFromElement(element) {
            if (element.id.includes('video')) return 'video';
            if (element.id.includes('audio')) return 'audio';
            if (element.id.includes('text')) return 'text';
            return 'video';
        }

        findClipAtPosition(trackType, timePosition) {
            return this.project.timeline.tracks[trackType].find(clip =>
                timePosition >= clip.startTime && timePosition <= clip.endTime
            );
        }

        applyEffectToClip(clip, effect) {
            if (!clip.effects) clip.effects = [];

            const effectObj = {
                id: this.generateId(),
                type: effect,
                parameters: this.getDefaultEffectParameters(effect),
                startTime: 0,
                duration: clip.duration
            };

            clip.effects.push(effectObj);
            this.updateTimeline();

            console.log(`Applied ${effect} effect to clip:`, clip.mediaItem.fileName);
        }

        getDefaultEffectParameters(effect) {
            const defaults = {
                'fade-in': { duration: 1 },
                'fade-out': { duration: 1 },
                'blur': { radius: 5 },
                'brightness': { value: 20 },
                'crossfade': { duration: 2 }
            };
            return defaults[effect] || {};
        }

        addTextClip(template, startTime) {
            const textClip = {
                id: this.generateId(),
                mediaId: 'text_' + Date.now(),
                mediaItem: {
                    id: 'text_' + Date.now(),
                    fileName: template.replace('-', ' ').toUpperCase(),
                    hasVideo: false,
                    hasAudio: false
                },
                trackType: 'text',
                startTime: startTime,
                duration: 3,
                endTime: startTime + 3,
                effects: [],
                textContent: {
                    text: 'Your Text Here',
                    template: template,
                    fontSize: template === 'title' ? 48 : template === 'subtitle' ? 32 : 24,
                    color: '#ffffff',
                    position: { x: 50, y: template === 'lower-third' ? 80 : 50 }
                }
            };

            this.project.timeline.tracks.text.push(textClip);
            this.updateTimeline();
            this.enableExport();
        }

        async addClipToTrack(mediaItem, trackType, startTime = 0, duration = null) {
            // Validate track type compatibility
            if (trackType === 'video' && !mediaItem.hasVideo) {
                trackType = 'audio'; // Auto-redirect audio-only files to audio track
            } else if (trackType === 'audio' && !mediaItem.hasAudio) {
                alert('This file has no audio track');
                return;
            }

            const clipDuration = duration || mediaItem.duration;
            const clip = {
                id: this.generateId(),
                mediaId: mediaItem.id,
                mediaItem: mediaItem,
                trackType: trackType,
                startTime: startTime,
                duration: clipDuration,
                endTime: startTime + clipDuration,
                effects: [],
                speed: 1,
                volume: 100,
                opacity: 100,
                transform: { x: 0, y: 0, scale: 100, rotation: 0 }
            };

            // Snap to grid if enabled
            if (this.snapEnabled) {
                clip.startTime = this.snapToGrid(clip.startTime);
                clip.endTime = clip.startTime + clip.duration;
            }

            this.project.timeline.tracks[trackType].push(clip);
            this.updateTimeline();
            this.enableExport();

            // Auto-load preview for first video clip
            if (trackType === 'video' && mediaItem.hasVideo && !this.previewVideo.src) {
                this.loadPreview(mediaItem);
            }

            console.log(`Added ${mediaItem.fileName} to ${trackType} track at ${startTime.toFixed(2)}s`);
        }

        snapToGrid(time) {
            const snapInterval = 1 / this.zoomLevel; // Dynamic snap based on zoom
            return Math.round(time / snapInterval) * snapInterval;
        }

        loadPreview(mediaItem) {
            try {
                if (!mediaItem.hasVideo) {
                    this.previewPlaceholder.innerHTML = `
                        <div>Audio Only</div>
                        <div style="font-size: 0.8rem; margin-top: 10px; color: #ccc;">
                            ${mediaItem.fileName}
                        </div>
                    `;
                    return;
                }

                if (!window.electronAPI) {
                    // Browser demo mode
                    this.previewPlaceholder.innerHTML = `
                        <div>Demo Preview</div>
                        <div style="font-size: 0.8rem; margin-top: 10px; color: #ccc;">
                            ${mediaItem.fileName}
                        </div>
                        <div style="font-size: 0.8rem; margin-top: 5px; color: #666;">
                            Electron app required for video preview
                        </div>
                    `;
                    return;
                }

                // Clear any existing source
                this.previewVideo.src = '';
                this.previewVideo.load();

                // Set new source with proper file protocol
                const videoSrc = window.electronAPI.getVideoUrl(mediaItem.filePath);
                console.log('Loading preview:', videoSrc);

                this.previewVideo.src = videoSrc;
                this.previewVideo.load();

                this.previewPlaceholder.innerHTML = `
                    <div>Loading video...</div>
                    <div style="font-size: 0.8rem; margin-top: 10px; color: #ccc;">
                        ${mediaItem.fileName}
                    </div>
                `;

            } catch (error) {
                console.error('Error loading preview:', error);
                this.previewPlaceholder.innerHTML = `
                    <div>Preview Error</div>
                    <div style="font-size: 0.8rem; margin-top: 10px; color: #ff6b6b;">
                        ${error.message}
                    </div>
                `;
            }
        }

        // Timeline management
        updateTimeline() {
            this.renderTimelineRuler();
            this.renderTracks();
            this.updateProjectDuration();
        }

        renderTimelineRuler() {
            const timelineWidth = Math.max(800, this.project.timeline.duration * this.pixelsPerSecond * this.zoomLevel);
            this.timelineRuler.style.minWidth = timelineWidth + 'px';

            // Clear existing marks
            this.timelineRuler.querySelectorAll('.ruler-mark, .ruler-time').forEach(el => el.remove());

            const interval = this.zoomLevel < 0.5 ? 10 : this.zoomLevel < 1 ? 5 : this.zoomLevel < 2 ? 2 : 1;

            for (let i = 0; i <= this.project.timeline.duration; i += interval) {
                const x = i * this.pixelsPerSecond * this.zoomLevel;

                const mark = document.createElement('div');
                mark.className = 'ruler-mark';
                mark.style.left = x + 'px';
                this.timelineRuler.appendChild(mark);

                if (i % (interval * 2) === 0) {
                    const timeLabel = document.createElement('div');
                    timeLabel.className = 'ruler-time';
                    timeLabel.style.left = x + 'px';
                    timeLabel.textContent = this.formatTime(i);
                    this.timelineRuler.appendChild(timeLabel);
                }
            }
        }

        renderTracks() {
            ['video', 'audio', 'text'].forEach(trackType => {
                const trackContent = document.getElementById(`${trackType}TrackContent`);
                trackContent.innerHTML = '';

                const clips = this.project.timeline.tracks[trackType];
                clips.forEach(clip => this.renderClip(clip, trackContent));
            });

            this.updatePlayheadPosition(this.playhead);
        }

        renderClip(clip, trackContent) {
            const clipElement = document.createElement('div');
            clipElement.className = `clip ${clip.trackType}`;
            clipElement.dataset.clipId = clip.id;

            const left = clip.startTime * this.pixelsPerSecond * this.zoomLevel;
            const width = clip.duration * this.pixelsPerSecond * this.zoomLevel;

            clipElement.style.left = left + 'px';
            clipElement.style.width = width + 'px';

            // Add speed indicator if not normal speed
            if (clip.speed !== 1) {
                const speedIndicator = document.createElement('div');
                speedIndicator.className = 'speed-indicator';
                speedIndicator.textContent = clip.speed + 'x';
                clipElement.appendChild(speedIndicator);
            }

            // Add waveform for audio clips
            if (clip.trackType === 'audio' || (clip.trackType === 'video' && clip.mediaItem.hasAudio)) {
                const waveform = this.generateWaveform(clip);
                clipElement.appendChild(waveform);
            }

            const clipName = document.createElement('div');
            clipName.className = 'clip-name';
            clipName.textContent = clip.mediaItem.fileName;
            clipElement.appendChild(clipName);

            // Add resize handles
            const leftHandle = document.createElement('div');
            leftHandle.className = 'clip-handle left';
            clipElement.appendChild(leftHandle);

            const rightHandle = document.createElement('div');
            rightHandle.className = 'clip-handle right';
            clipElement.appendChild(rightHandle);

            // Bind events
            this.bindClipEvents(clipElement, clip);

            trackContent.appendChild(clipElement);
        }

        generateWaveform(clip) {
            const waveform = document.createElement('div');
            waveform.className = 'audio-waveform';

            // Generate fake waveform bars
            const barCount = Math.max(10, Math.floor(clip.duration * 10));
            for (let i = 0; i < barCount; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = (Math.random() * 80 + 20) + '%';
                waveform.appendChild(bar);
            }

            return waveform;
        }

        bindClipEvents(clipElement, clip) {
            clipElement.addEventListener('click', e => {
                e.stopPropagation();
                this.selectClip(clip);
            });

            clipElement.addEventListener('mousedown', e => {
                if (e.target.classList.contains('clip-handle')) {
                    this.startResizing(e, clip, e.target.classList.contains('left') ? 'left' : 'right');
                } else {
                    this.startDragging(e, clip);
                }
            });
        }

        selectClip(clip) {
            // Deselect previous clip
            document.querySelectorAll('.clip.selected').forEach(el => {
                el.classList.remove('selected');
            });

            // Select new clip
            const clipElement = document.querySelector(`[data-clip-id="${clip.id}"]`);
            if (clipElement) {
                clipElement.classList.add('selected');
            }

            this.selectedClip = clip;
            this.updateClipProperties();
            this.enableClipTools();
        }

        updateClipProperties() {
            if (!this.selectedClip) {
                this.clearClipProperties();
                return;
            }

            const clip = this.selectedClip;
            this.clipName.value = clip.mediaItem.fileName;
            this.clipStart.value = clip.startTime.toFixed(2);
            this.clipEnd.value = clip.endTime.toFixed(2);
            this.clipSpeed.value = clip.speed;

            // Update sliders
            if (clip.opacity !== undefined) {
                document.getElementById('opacitySlider').value = clip.opacity;
                document.getElementById('opacityValue').textContent = clip.opacity + '%';
            }

            if (clip.transform) {
                document.getElementById('scaleSlider').value = clip.transform.scale;
                document.getElementById('scaleValue').textContent = clip.transform.scale + '%';
                document.getElementById('posX').value = clip.transform.x;
                document.getElementById('posY').value = clip.transform.y;
                document.getElementById('rotation').value = clip.transform.rotation;
            }
        }

        clearClipProperties() {
            this.clipName.value = '';
            this.clipStart.value = '';
            this.clipEnd.value = '';
            this.clipSpeed.value = '1';

            // Reset all sliders to default
            document.getElementById('opacitySlider').value = '100';
            document.getElementById('opacityValue').textContent = '100%';
            document.getElementById('blurSlider').value = '0';
            document.getElementById('blurValue').textContent = '0';
            document.getElementById('brightnessSlider').value = '0';
            document.getElementById('brightnessValue').textContent = '0';
            document.getElementById('contrastSlider').value = '100';
            document.getElementById('contrastValue').textContent = '100%';
            document.getElementById('scaleSlider').value = '100';
            document.getElementById('scaleValue').textContent = '100%';
            document.getElementById('posX').value = '0';
            document.getElementById('posY').value = '0';
            document.getElementById('rotation').value = '0';
        }

        enableClipTools() {
            const buttons = ['splitClipBtn', 'duplicateClipBtn', 'deleteClipBtn', 'reverseClipBtn', 'extractAudioBtn', 'applyClipChanges'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = false;
            });
        }

        disableClipTools() {
            const buttons = ['splitClipBtn', 'duplicateClipBtn', 'deleteClipBtn', 'reverseClipBtn', 'extractAudioBtn', 'applyClipChanges'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = true;
            });
        }

        enableExport() {
            this.exportBtn.disabled = !this.hasClips();
        }

        hasClips() {
            return Object.values(this.project.timeline.tracks).some(track => track.length > 0);
        }

        startDragging(e, clip) {
            this.dragState = {
                type: 'move',
                clip: clip,
                startX: e.clientX,
                startTime: clip.startTime,
                active: true
            };

            document.addEventListener('mousemove', this.handleDrag.bind(this));
            document.addEventListener('mouseup', this.stopDrag.bind(this));
        }

        startResizing(e, clip, side) {
            this.dragState = {
                type: 'resize',
                clip: clip,
                side: side,
                startX: e.clientX,
                startTime: clip.startTime,
                startDuration: clip.duration,
                active: true
            };

            document.addEventListener('mousemove', this.handleDrag.bind(this));
            document.addEventListener('mouseup', this.stopDrag.bind(this));
        }

        handleDrag(e) {
            if (!this.dragState || !this.dragState.active) return;

            const deltaX = e.clientX - this.dragState.startX;
            const deltaTime = deltaX / (this.pixelsPerSecond * this.zoomLevel);

            if (this.dragState.type === 'move') {
                const newStartTime = Math.max(0, this.dragState.startTime + deltaTime);
                this.dragState.clip.startTime = this.snapEnabled ? this.snapToGrid(newStartTime) : newStartTime;
                this.dragState.clip.endTime = this.dragState.clip.startTime + this.dragState.clip.duration;
            } else if (this.dragState.type === 'resize') {
                if (this.dragState.side === 'left') {
                    const newStartTime = Math.max(0, this.dragState.startTime + deltaTime);
                    const newDuration = this.dragState.startDuration - (newStartTime - this.dragState.startTime);
                    if (newDuration > 0.1) {
                        this.dragState.clip.startTime = this.snapEnabled ? this.snapToGrid(newStartTime) : newStartTime;
                        this.dragState.clip.duration = newDuration;
                        this.dragState.clip.endTime = this.dragState.clip.startTime + this.dragState.clip.duration;
                    }
                } else {
                    const newDuration = Math.max(0.1, this.dragState.startDuration + deltaTime);
                    this.dragState.clip.duration = newDuration;
                    this.dragState.clip.endTime = this.dragState.clip.startTime + this.dragState.clip.duration;
                }
            }

            this.renderTracks();
            if (this.selectedClip === this.dragState.clip) {
                this.updateClipProperties();
            }
        }

        stopDrag() {
            if (this.dragState && this.dragState.active) {
                this.dragState.active = false;
                this.updateTimeline();
            }

            document.removeEventListener('mousemove', this.handleDrag);
            document.removeEventListener('mouseup', this.stopDrag);
        }

        updateProjectDuration() {
            let maxDuration = 0;
            Object.values(this.project.timeline.tracks).forEach(track => {
                track.forEach(clip => {
                    maxDuration = Math.max(maxDuration, clip.endTime);
                });
            });

            this.project.timeline.duration = Math.max(maxDuration, 10);
        }

        // Playback controls
        togglePlay() {
            if (this.isPlaying) {
                this.pause();
            } else {
                this.play();
            }
        }

        play() {
            this.isPlaying = true;
            this.playBtn.textContent = '⏸';

            if (this.previewVideo.src && this.previewVideo.readyState >= 2) {
                this.previewVideo.currentTime = this.playhead;
                this.previewVideo.play();
                this.previewVideo.style.display = 'block';
                this.previewPlaceholder.style.display = 'none';
            }

            this.startPlaybackTimer();
        }

        pause() {
            this.isPlaying = false;
            this.playBtn.textContent = '▶';

            if (this.previewVideo.src) {
                this.previewVideo.pause();
            }

            this.stopPlaybackTimer();
        }

        startPlaybackTimer() {
            this.playbackTimer = setInterval(() => {
                if (this.isPlaying) {
                    this.playhead += 1/30; // 30fps

                    if (this.playhead >= this.project.timeline.duration) {
                        this.playhead = 0;
                        this.pause();
                    }

                    this.updatePlayheadPosition(this.playhead);
                    this.updateTimeDisplays();
                }
            }, 1000/30);
        }

        stopPlaybackTimer() {
            if (this.playbackTimer) {
                clearInterval(this.playbackTimer);
                this.playbackTimer = null;
            }
        }

        updatePlayheadPosition(time) {
            const x = time * this.pixelsPerSecond * this.zoomLevel;
            this.playheadElement.style.left = x + 'px';

            // Update preview video time
            if (this.previewVideo.src && !this.isPlaying) {
                this.previewVideo.currentTime = time;
            }
        }

        updateTimeDisplays() {
            this.currentTime.textContent = this.formatTime(this.playhead);
            this.totalTime.textContent = this.formatTime(this.project.timeline.duration);

            // Update playback slider
            const progress = (this.playhead / this.project.timeline.duration) * 100;
            this.sliderProgress.style.width = progress + '%';
        }

        scrubTimeline(e) {
            const rect = this.timelineRuler.getBoundingClientRect();
            const x = e.clientX - rect.left + this.timelineScroll;
            const time = Math.max(0, x / (this.pixelsPerSecond * this.zoomLevel));

            this.playhead = Math.min(time, this.project.timeline.duration);
            this.updatePlayheadPosition(this.playhead);
            this.updateTimeDisplays();
        }

        scrubToPosition(e) {
            const rect = this.playbackSlider.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const progress = Math.max(0, Math.min(1, x / rect.width));

            this.playhead = progress * this.project.timeline.duration;
            this.updatePlayheadPosition(this.playhead);
            this.updateTimeDisplays();
        }

        frameStep(direction) {
            const frameTime = 1 / this.project.settings.fps;
            this.playhead = Math.max(0, Math.min(this.project.timeline.duration, this.playhead + (direction * frameTime)));
            this.updatePlayheadPosition(this.playhead);
            this.updateTimeDisplays();
        }

        // Zoom controls
        zoomIn() {
            this.zoomLevel = Math.min(4, this.zoomLevel * 1.5);
            this.updateZoomDisplay();
            this.updateTimeline();
        }

        zoomOut() {
            this.zoomLevel = Math.max(0.25, this.zoomLevel / 1.5);
            this.updateZoomDisplay();
            this.updateTimeline();
        }

        fitToWindow() {
            const containerWidth = this.timelineContainer.clientWidth - 100;
            this.zoomLevel = Math.max(0.25, containerWidth / (this.project.timeline.duration * this.pixelsPerSecond));
            this.updateZoomDisplay();
            this.updateTimeline();
        }

        updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(this.zoomLevel * 100) + '%';
        }

        // Tool toggles
        toggleSnap() {
            this.snapEnabled = !this.snapEnabled;
            this.snapBtn.classList.toggle('active', this.snapEnabled);
            this.magnetBtn.classList.toggle('active', this.snapEnabled);
        }

        toggleMagnet() {
            this.toggleSnap();
        }

        toggleRipple() {
            this.rippleMode = !this.rippleMode;
            this.rippleBtn.classList.toggle('active', this.rippleMode);
        }

        toggleRazor() {
            this.razorMode = !this.razorMode;
            this.razorBtn.classList.toggle('active', this.razorMode);
            document.body.style.cursor = this.razorMode ? 'crosshair' : 'default';
        }

        // Clip operations
        splitClip() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            const splitTime = this.playhead;

            if (splitTime <= clip.startTime || splitTime >= clip.endTime) {
                alert('Playhead must be within the selected clip to split');
                return;
            }

            const firstPart = { ...clip };
            firstPart.id = this.generateId();
            firstPart.duration = splitTime - clip.startTime;
            firstPart.endTime = splitTime;

            const secondPart = { ...clip };
            secondPart.id = this.generateId();
            secondPart.startTime = splitTime;
            secondPart.duration = clip.endTime - splitTime;

            // Remove original clip
            const trackIndex = this.project.timeline.tracks[clip.trackType].indexOf(clip);
            this.project.timeline.tracks[clip.trackType].splice(trackIndex, 1);

            // Add split parts
            this.project.timeline.tracks[clip.trackType].push(firstPart, secondPart);

            this.selectedClip = firstPart;
            this.updateTimeline();
        }

        duplicateClip() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            const duplicate = { ...clip };
            duplicate.id = this.generateId();
            duplicate.startTime = clip.endTime;
            duplicate.endTime = duplicate.startTime + duplicate.duration;

            this.project.timeline.tracks[clip.trackType].push(duplicate);
            this.updateTimeline();
            this.selectClip(duplicate);
        }

        deleteClip() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            const trackIndex = this.project.timeline.tracks[clip.trackType].indexOf(clip);
            this.project.timeline.tracks[clip.trackType].splice(trackIndex, 1);

            this.selectedClip = null;
            this.updateTimeline();
            this.clearClipProperties();
            this.disableClipTools();
            this.enableExport();
        }

        reverseClip() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            if (!clip.effects) clip.effects = [];

            const reverseEffect = {
                id: this.generateId(),
                type: 'reverse',
                parameters: {},
                startTime: 0,
                duration: clip.duration
            };

            clip.effects.push(reverseEffect);
            this.updateTimeline();

            console.log('Applied reverse effect to clip:', clip.mediaItem.fileName);
        }

        extractAudio() {
            if (!this.selectedClip || !this.selectedClip.mediaItem.hasAudio) return;

            const clip = this.selectedClip;
            const audioClip = {
                ...clip,
                id: this.generateId(),
                trackType: 'audio',
                mediaItem: {
                    ...clip.mediaItem,
                    fileName: clip.mediaItem.fileName.replace(/\.[^.]+$/, '.audio'),
                    hasVideo: false
                }
            };

            this.project.timeline.tracks.audio.push(audioClip);
            this.updateTimeline();

            console.log('Extracted audio from clip:', clip.mediaItem.fileName);
        }

        cutClip() {
            if (!this.selectedClip) return;
            this.copiedClip = { ...this.selectedClip };
            this.deleteClip();
        }

        copyClip() {
            if (!this.selectedClip) return;
            this.copiedClip = { ...this.selectedClip };
        }

        pasteClip() {
            if (!this.copiedClip) return;

            const clip = { ...this.copiedClip };
            clip.id = this.generateId();
            clip.startTime = this.playhead;
            clip.endTime = clip.startTime + clip.duration;

            this.project.timeline.tracks[clip.trackType].push(clip);
            this.updateTimeline();
            this.selectClip(clip);
        }

        applyClipChanges() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            const newStartTime = parseFloat(this.clipStart.value) || 0;
            const newEndTime = parseFloat(this.clipEnd.value) || clip.endTime;
            const newSpeed = parseFloat(this.clipSpeed.value) || 1;

            clip.startTime = Math.max(0, newStartTime);
            clip.endTime = Math.max(clip.startTime + 0.1, newEndTime);
            clip.duration = clip.endTime - clip.startTime;
            clip.speed = newSpeed;

            this.updateTimeline();
            this.updateClipProperties();
        }

        updateClipSpeed() {
            if (!this.selectedClip) return;

            const speed = parseFloat(this.clipSpeed.value) || 1;
            this.selectedClip.speed = speed;
            this.updateTimeline();
        }

        updateClipEffects() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            clip.opacity = parseInt(document.getElementById('opacitySlider').value);

            // Apply visual effects
            const effects = {
                blur: parseFloat(document.getElementById('blurSlider').value),
                brightness: parseInt(document.getElementById('brightnessSlider').value),
                contrast: parseInt(document.getElementById('contrastSlider').value)
            };

            if (!clip.visualEffects) clip.visualEffects = {};
            Object.assign(clip.visualEffects, effects);
        }

        updateClipTransform() {
            if (!this.selectedClip) return;

            const clip = this.selectedClip;
            if (!clip.transform) clip.transform = {};

            clip.transform.x = parseFloat(document.getElementById('posX').value) || 0;
            clip.transform.y = parseFloat(document.getElementById('posY').value) || 0;
            clip.transform.rotation = parseFloat(document.getElementById('rotation').value) || 0;
            clip.transform.scale = parseInt(document.getElementById('scaleSlider').value) || 100;
        }

        // Context menu
        showContextMenu(e) {
            if (!e.target.closest('.clip')) return;

            e.preventDefault();
            this.contextMenu.style.display = 'block';
            this.contextMenu.style.left = e.clientX + 'px';
            this.contextMenu.style.top = e.clientY + 'px';
        }

        hideContextMenu() {
            this.contextMenu.style.display = 'none';
        }

        showSpeedDialog() {
            const speed = prompt('Enter playback speed (0.25 - 4):', this.selectedClip ? this.selectedClip.speed : '1');
            if (speed && this.selectedClip) {
                const newSpeed = parseFloat(speed);
                if (newSpeed >= 0.25 && newSpeed <= 4) {
                    this.selectedClip.speed = newSpeed;
                    this.clipSpeed.value = newSpeed;
                    this.updateTimeline();
                }
            }
        }

        // Track management
        addTrack() {
            const trackType = prompt('Track type (video/audio/text):', 'video');
            if (!['video', 'audio', 'text'].includes(trackType)) return;

            this.trackCount[trackType]++;
            const trackId = `${trackType}Track${this.trackCount[trackType]}`;

            const track = document.createElement('div');
            track.className = 'track';
            track.id = trackId;

            track.innerHTML = `
                <div class="track-label">${trackType.charAt(0).toUpperCase() + trackType.slice(1)} ${this.trackCount[trackType]}</div>
                <div class="track-content" id="${trackId}Content"></div>
            `;

            this.tracksContainer.appendChild(track);

            // Make droppable
            const trackContent = track.querySelector('.track-content');
            trackContent.addEventListener('dragover', e => e.preventDefault());
            trackContent.addEventListener('drop', e => this.handleTrackDrop(e));
        }

        // Keyboard shortcuts
        handleKeyboard(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    this.togglePlay();
                    break;
                case 'Delete':
                case 'Backspace':
                    if (this.selectedClip) this.deleteClip();
                    break;
                case 'KeyS':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (this.selectedClip) this.splitClip();
                    }
                    break;
                case 'KeyD':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (this.selectedClip) this.duplicateClip();
                    }
                    break;
                case 'KeyC':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.copyClip();
                    }
                    break;
                case 'KeyV':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.pasteClip();
                    }
                    break;
                case 'KeyX':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        this.cutClip();
                    }
                    break;
                case 'KeyZ':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        // Undo functionality would be implemented here
                        console.log('Undo (not implemented)');
                    }
                    break;
                case 'ArrowLeft':
                    if (e.shiftKey) this.frameStep(-1);
                    else this.scrubTimeline({ clientX: this.playheadElement.offsetLeft - 10, currentTarget: this.timelineRuler });
                    break;
                case 'ArrowRight':
                    if (e.shiftKey) this.frameStep(1);
                    else this.scrubTimeline({ clientX: this.playheadElement.offsetLeft + 10, currentTarget: this.timelineRuler });
                    break;
                case 'Equal':
                case 'NumpadAdd':
                    this.zoomIn();
                    break;
                case 'Minus':
                case 'NumpadSubtract':
                    this.zoomOut();
                    break;
                case 'Digit0':
                    this.fitToWindow();
                    break;
            }
        }

        // Export functionality
        async exportVideo() {
            if (!this.hasClips()) {
                alert('Please add some clips to the timeline before exporting');
                return;
            }

            if (!window.electronAPI) {
                this.showBrowserExportDemo();
                return;
            }

            try {
                const outputPath = await window.electronAPI.saveVideoDialog();
                if (!outputPath) return;

                this.showProgress('Exporting Video');

                // Collect and sort all clips
                const allClips = [];
                Object.keys(this.project.timeline.tracks).forEach(trackType => {
                    this.project.timeline.tracks[trackType].forEach(clip => {
                        allClips.push(clip);
                    });
                });

                allClips.sort((a, b) => a.startTime - b.startTime);

                // Process video segments
                const processedSegments = [];
                const videoClips = allClips.filter(clip => clip.trackType === 'video' && clip.mediaItem.hasVideo);

                for (let i = 0; i < videoClips.length; i++) {
                    const clip = videoClips[i];
                    this.updateProgress(30 + (i / videoClips.length) * 50);

                    const result = await window.electronAPI.trimVideoSegment({
                        inputPath: clip.mediaItem.filePath,
                        startTime: clip.startTime,
                        endTime: clip.endTime,
                        segmentId: clip.id,
                        speed: clip.speed || 1,
                        effects: clip.effects || []
                    });

                    processedSegments.push({
                        path: result.outputPath,
                        id: result.segmentId,
                        timelineStart: clip.startTime
                    });
                }

                this.updateProgress(80);

                // Merge segments
                await window.electronAPI.mergeVideos({
                    segments: processedSegments,
                    outputPath: outputPath,
                    settings: this.project.settings
                });

            } catch (error) {
                console.error('Export error:', error);
                this.hideProgress();
                alert('Error exporting video: ' + error.message);
            }
        }

        showBrowserExportDemo() {
            this.showProgress('Demo Export');

            // Simulate export progress
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                this.updateProgress(Math.min(progress, 100));

                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        this.hideProgress();
                        alert('Demo export completed! In the full Electron app, your video would be saved.');
                    }, 1000);
                }
            }, 200);
        }

        showProgress(title) {
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = '0%';
            this.progressOverlay.style.display = 'flex';
        }

        hideProgress() {
            this.progressOverlay.style.display = 'none';
        }

        updateProgress(percent) {
            const clampedPercent = Math.max(0, Math.min(100, percent));
            document.getElementById('progressFill').style.width = clampedPercent + '%';
            document.getElementById('progressText').textContent = Math.round(clampedPercent) + '%';
        }

        // Project management
        newProject() {
            if (this.hasClips() && !confirm('Create new project? Current work will be lost.')) {
                return;
            }

            this.project = {
                name: 'Untitled Project',
                timeline: {
                    duration: 0,
                    tracks: { video: [], audio: [], text: [] }
                },
                settings: {
                    resolution: '1080p',
                    format: 'mp4',
                    bitrate: 8,
                    fps: 30
                }
            };

            this.selectedClip = null;
            this.playhead = 0;
            this.copiedClip = null;
            this.updateTimeline();
            this.clearClipProperties();
            this.enableExport();

            // Clear preview
            this.previewVideo.src = '';
            this.previewPlaceholder.style.display = 'block';
            this.previewVideo.style.display = 'none';

            console.log('New project created');
        }

        async saveProject() {
            const projectData = JSON.stringify(this.project, null, 2);

            if (window.electronAPI) {
                try {
                    const filePath = await window.electronAPI.saveProjectDialog();
                    if (filePath) {
                        await window.electronAPI.writeFile(filePath, projectData);
                        console.log('Project saved to:', filePath);
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    alert('Error saving project: ' + error.message);
                }
            } else {
                // Browser fallback - download as file
                const blob = new Blob([projectData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.project.name}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        async openProject() {
            if (window.electronAPI) {
                try {
                    const filePath = await window.electronAPI.openProjectDialog();
                    if (filePath) {
                        const projectData = await window.electronAPI.readFile(filePath);
                        this.project = JSON.parse(projectData);
                        this.updateTimeline();
                        console.log('Project loaded from:', filePath);
                    }
                } catch (error) {
                    console.error('Open error:', error);
                    alert('Error opening project: ' + error.message);
                }
            } else {
                // Browser fallback - file input
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                this.project = JSON.parse(e.target.result);
                                this.updateTimeline();
                                console.log('Project loaded');
                            } catch (error) {
                                alert('Invalid project file');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }
        }

        // Utility functions
        generateId() {
            return 'clip_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    }

    // Initialize the video editor when the page loads
    document.addEventListener('DOMContentLoaded', () => {
        window.videoEditor = new VideoEditor();
        console.log('Video Editor initialized');
    });
</script>
</body>
</html>
